{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport isValidNumber from '../validate_.js';\nimport parseDigits from '../helpers/parseDigits.js';\nimport { startsWith, endsWith } from './util.js';\n/**\r\n * Leniency when finding potential phone numbers in text segments\r\n * The levels here are ordered in increasing strictness.\r\n */\n\nexport default {\n  /**\r\n   * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\r\n   */\n  POSSIBLE: function POSSIBLE(number, candidate, metadata) {\n    return true;\n  },\n  /**\r\n   * Phone numbers accepted are \"possible\" and \"valid\".\r\n   * Numbers written in national format must have their national-prefix\r\n   * present if it is usually written for a number of this type.\r\n   */\n  VALID: function VALID(number, candidate, metadata) {\n    if (!isValidNumber(number, undefined, metadata) || !containsOnlyValidXChars(number, candidate.toString(), metadata)) {\n      return false;\n    } // Skipped for simplicity.\n    // return isNationalPrefixPresentIfRequired(number, metadata)\n\n    return true;\n  },\n  /**\r\n   * Phone numbers accepted are \"valid\" and\r\n   * are grouped in a possible way for this locale. For example, a US number written as\r\n   * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\r\n   * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\r\n   * Numbers with more than one '/' symbol in the national significant number\r\n   * are also dropped at this level.\r\n   *\r\n   * Warning: This level might result in lower coverage especially for regions outside of\r\n   * country code \"+1\". If you are not sure about which level to use,\r\n   * email the discussion group libphonenumber-discuss@googlegroups.com.\r\n   */\n  STRICT_GROUPING: function STRICT_GROUPING(number, candidate, metadata, regExpCache) {\n    var candidateString = candidate.toString();\n    if (!isValidNumber(number, undefined, metadata) || !containsOnlyValidXChars(number, candidateString, metadata) || containsMoreThanOneSlashInNationalNumber(number, candidateString) || !isNationalPrefixPresentIfRequired(number, metadata)) {\n      return false;\n    }\n    return checkNumberGroupingIsValid(number, candidate, metadata, allNumberGroupsRemainGrouped, regExpCache);\n  },\n  /**\r\n   * Phone numbers accepted are {@linkplain PhoneNumberUtil#isValidNumber(PhoneNumber) valid} and\r\n   * are grouped in the same way that we would have formatted it, or as a single block. For\r\n   * example, a US number written as \"650 2530000\" is not accepted at this leniency level, whereas\r\n   * \"650 253 0000\" or \"6502530000\" are.\r\n   * Numbers with more than one '/' symbol are also dropped at this level.\r\n   * <p>\r\n   * Warning: This level might result in lower coverage especially for regions outside of country\r\n   * code \"+1\". If you are not sure about which level to use, email the discussion group\r\n   * libphonenumber-discuss@googlegroups.com.\r\n   */\n  EXACT_GROUPING: function EXACT_GROUPING(number, candidate, metadata, regExpCache) {\n    var candidateString = candidate.toString();\n    if (!isValidNumber(number, undefined, metadata) || !containsOnlyValidXChars(number, candidateString, metadata) || containsMoreThanOneSlashInNationalNumber(number, candidateString) || !isNationalPrefixPresentIfRequired(number, metadata)) {\n      return false;\n    }\n    return checkNumberGroupingIsValid(number, candidate, metadata, allNumberGroupsAreExactlyPresent, regExpCache);\n  }\n};\nfunction containsOnlyValidXChars(number, candidate, metadata) {\n  // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\n  // national significant number or (2) an extension sign, in which case they always precede the\n  // extension number. We assume a carrier code is more than 1 digit, so the first case has to\n  // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\n  // or 'X'. We ignore the character if it appears as the last character of the string.\n  for (var index = 0; index < candidate.length - 1; index++) {\n    var charAtIndex = candidate.charAt(index);\n    if (charAtIndex === 'x' || charAtIndex === 'X') {\n      var charAtNextIndex = candidate.charAt(index + 1);\n      if (charAtNextIndex === 'x' || charAtNextIndex === 'X') {\n        // This is the carrier code case, in which the 'X's always precede the national\n        // significant number.\n        index++;\n        if (util.isNumberMatch(number, candidate.substring(index)) != MatchType.NSN_MATCH) {\n          return false;\n        } // This is the extension sign case, in which the 'x' or 'X' should always precede the\n        // extension number.\n      } else if (parseDigits(candidate.substring(index)) !== number.ext) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction isNationalPrefixPresentIfRequired(number, _metadata) {\n  // First, check how we deduced the country code. If it was written in international format, then\n  // the national prefix is not required.\n  if (number.getCountryCodeSource() != 'FROM_DEFAULT_COUNTRY') {\n    return true;\n  }\n  var phoneNumberRegion = util.getRegionCodeForCountryCode(number.getCountryCode());\n  var metadata = util.getMetadataForRegion(phoneNumberRegion);\n  if (metadata == null) {\n    return true;\n  } // Check if a national prefix should be present when formatting this number.\n\n  var nationalNumber = util.getNationalSignificantNumber(number);\n  var formatRule = util.chooseFormattingPatternForNumber(metadata.numberFormats(), nationalNumber); // To do this, we check that a national prefix formatting rule was present\n  // and that it wasn't just the first-group symbol ($1) with punctuation.\n\n  if (formatRule && formatRule.getNationalPrefixFormattingRule().length > 0) {\n    if (formatRule.getNationalPrefixOptionalWhenFormatting()) {\n      // The national-prefix is optional in these cases, so we don't need to check if it was\n      // present.\n      return true;\n    }\n    if (PhoneNumberUtil.formattingRuleHasFirstGroupOnly(formatRule.getNationalPrefixFormattingRule())) {\n      // National Prefix not needed for this number.\n      return true;\n    } // Normalize the remainder.\n\n    var rawInputCopy = PhoneNumberUtil.normalizeDigitsOnly(number.getRawInput()); // Check if we found a national prefix and/or carrier code at the start of the raw input, and\n    // return the result.\n\n    return util.maybeStripNationalPrefixAndCarrierCode(rawInputCopy, metadata, null);\n  }\n  return true;\n}\nexport function containsMoreThanOneSlashInNationalNumber(number, candidate) {\n  var firstSlashInBodyIndex = candidate.indexOf('/');\n  if (firstSlashInBodyIndex < 0) {\n    // No slashes, this is okay.\n    return false;\n  } // Now look for a second one.\n\n  var secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1);\n  if (secondSlashInBodyIndex < 0) {\n    // Only one slash, this is okay.\n    return false;\n  } // If the first slash is after the country calling code, this is permitted.\n\n  var candidateHasCountryCode = number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN || number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITHOUT_PLUS_SIGN;\n  if (candidateHasCountryCode && PhoneNumberUtil.normalizeDigitsOnly(candidate.substring(0, firstSlashInBodyIndex)) === String(number.getCountryCode())) {\n    // Any more slashes and this is illegal.\n    return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0;\n  }\n  return true;\n}\nfunction checkNumberGroupingIsValid(number, candidate, metadata, checkGroups, regExpCache) {\n  var normalizedCandidate = normalizeDigits(candidate, true\n  /* keep non-digits */);\n\n  var formattedNumberGroups = getNationalNumberGroups(metadata, number, null);\n  if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\n    return true;\n  } // If this didn't pass, see if there are any alternate formats that match, and try them instead.\n\n  var alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode());\n  var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n  if (alternateFormats) {\n    for (var _iterator = _createForOfIteratorHelperLoose(alternateFormats.numberFormats()), _step; !(_step = _iterator()).done;) {\n      var alternateFormat = _step.value;\n      if (alternateFormat.leadingDigitsPatterns().length > 0) {\n        // There is only one leading digits pattern for alternate formats.\n        var leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0]);\n        if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {\n          // Leading digits don't match; try another one.\n          continue;\n        }\n      }\n      formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat);\n      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n/**\r\n * Helper method to get the national-number part of a number, formatted without any national\r\n * prefix, and return it as a set of digit blocks that would be formatted together following\r\n * standard formatting rules.\r\n */\n\nfunction getNationalNumberGroups(metadata, number, formattingPattern) {\n  if (formattingPattern) {\n    // We format the NSN only, and split that according to the separator.\n    var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n    return util.formatNsnUsingPattern(nationalSignificantNumber, formattingPattern, 'RFC3966', metadata).split('-');\n  } // This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.\n\n  var rfc3966Format = formatNumber(number, 'RFC3966', metadata); // We remove the extension part from the formatted string before splitting it into different\n  // groups.\n\n  var endIndex = rfc3966Format.indexOf(';');\n  if (endIndex < 0) {\n    endIndex = rfc3966Format.length;\n  } // The country-code will have a '-' following it.\n\n  var startIndex = rfc3966Format.indexOf('-') + 1;\n  return rfc3966Format.slice(startIndex, endIndex).split('-');\n}\nfunction allNumberGroupsAreExactlyPresent(metadata, number, normalizedCandidate, formattedNumberGroups) {\n  var candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN); // Set this to the last group, skipping it if the number has an extension.\n\n  var candidateNumberGroupIndex = number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1; // First we check if the national significant number is formatted as a block.\n  // We use contains and not equals, since the national significant number may be present with\n  // a prefix such as a national number prefix, or the country code itself.\n\n  if (candidateGroups.length == 1 || candidateGroups[candidateNumberGroupIndex].contains(util.getNationalSignificantNumber(number))) {\n    return true;\n  } // Starting from the end, go through in reverse, excluding the first group, and check the\n  // candidate and number groups are the same.\n\n  var formattedNumberGroupIndex = formattedNumberGroups.length - 1;\n  while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0) {\n    if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex]) {\n      return false;\n    }\n    formattedNumberGroupIndex--;\n    candidateNumberGroupIndex--;\n  } // Now check the first group. There may be a national prefix at the start, so we only check\n  // that the candidate group ends with the formatted number group.\n\n  return candidateNumberGroupIndex >= 0 && endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]);\n}\nfunction allNumberGroupsRemainGrouped(metadata, number, normalizedCandidate, formattedNumberGroups) {\n  var fromIndex = 0;\n  if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY) {\n    // First skip the country code if the normalized candidate contained it.\n    var countryCode = String(number.getCountryCode());\n    fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length();\n  } // Check each group of consecutive digits are not broken into separate groupings in the\n  // {@code normalizedCandidate} string.\n\n  for (var i = 0; i < formattedNumberGroups.length; i++) {\n    // Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\n    // doesn't contain the consecutive digits in formattedNumberGroups[i].\n    fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex);\n    if (fromIndex < 0) {\n      return false;\n    } // Moves {@code fromIndex} forward.\n\n    fromIndex += formattedNumberGroups[i].length();\n    if (i == 0 && fromIndex < normalizedCandidate.length()) {\n      // We are at the position right after the NDC. We get the region used for formatting\n      // information based on the country code in the phone number, rather than the number itself,\n      // as we do not need to distinguish between different countries with the same country\n      // calling code and this is faster.\n      var region = util.getRegionCodeForCountryCode(number.getCountryCode());\n      if (util.getNddPrefixForRegion(region, true) != null && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\n        // This means there is no formatting symbol after the NDC. In this case, we only\n        // accept the number if there is no formatting symbol at all in the number, except\n        // for extensions. This is only important for countries with national prefixes.\n        var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n        return startsWith(normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length), nationalSignificantNumber);\n      }\n    }\n  } // The check here makes sure that we haven't mistakenly already used the extension to\n  // match the last group of the subscriber number. Note the extension cannot have\n  // formatting in-between digits.\n\n  return normalizedCandidate.slice(fromIndex).contains(number.getExtension());\n}","map":{"version":3,"sources":["../../source/findNumbers/Leniency.js"],"names":["isValidNumber","parseDigits","startsWith","endsWith","POSSIBLE","number","candidate","metadata","VALID","undefined","containsOnlyValidXChars","toString","STRICT_GROUPING","regExpCache","candidateString","containsMoreThanOneSlashInNationalNumber","isNationalPrefixPresentIfRequired","checkNumberGroupingIsValid","allNumberGroupsRemainGrouped","EXACT_GROUPING","allNumberGroupsAreExactlyPresent","index","length","charAtIndex","charAt","charAtNextIndex","util","isNumberMatch","substring","MatchType","NSN_MATCH","ext","_metadata","getCountryCodeSource","phoneNumberRegion","getRegionCodeForCountryCode","getCountryCode","getMetadataForRegion","nationalNumber","getNationalSignificantNumber","formatRule","chooseFormattingPatternForNumber","numberFormats","getNationalPrefixFormattingRule","getNationalPrefixOptionalWhenFormatting","PhoneNumberUtil","formattingRuleHasFirstGroupOnly","rawInputCopy","normalizeDigitsOnly","getRawInput","maybeStripNationalPrefixAndCarrierCode","firstSlashInBodyIndex","indexOf","secondSlashInBodyIndex","candidateHasCountryCode","CountryCodeSource","FROM_NUMBER_WITH_PLUS_SIGN","FROM_NUMBER_WITHOUT_PLUS_SIGN","String","slice","checkGroups","normalizedCandidate","normalizeDigits","formattedNumberGroups","getNationalNumberGroups","alternateFormats","MetadataManager","getAlternateFormatsForCountry","nationalSignificantNumber","alternateFormat","leadingDigitsPatterns","leadingDigitsRegExp","getPatternForRegExp","test","formattingPattern","formatNsnUsingPattern","split","rfc3966Format","formatNumber","endIndex","startIndex","candidateGroups","NON_DIGITS_PATTERN","candidateNumberGroupIndex","hasExtension","contains","formattedNumberGroupIndex","fromIndex","FROM_DEFAULT_COUNTRY","countryCode","i","region","getNddPrefixForRegion","Character","isDigit","getExtension"],"mappings":"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","sourcesContent":["import isValidNumber from '../validate_.js'\r\nimport parseDigits from '../helpers/parseDigits.js'\r\n\r\nimport {\r\n\tstartsWith,\r\n\tendsWith\r\n} from './util.js'\r\n\r\n/**\r\n * Leniency when finding potential phone numbers in text segments\r\n * The levels here are ordered in increasing strictness.\r\n */\r\nexport default\r\n{\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\r\n\t */\r\n\tPOSSIBLE(number, candidate, metadata)\r\n\t{\r\n\t\treturn true\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\" and \"valid\".\r\n\t * Numbers written in national format must have their national-prefix\r\n\t * present if it is usually written for a number of this type.\r\n\t */\r\n\tVALID(number, candidate, metadata)\r\n\t{\r\n\t\tif (!isValidNumber(number, undefined, metadata) ||\r\n\t\t\t!containsOnlyValidXChars(number, candidate.toString(), metadata))\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n    // Skipped for simplicity.\r\n\t\t// return isNationalPrefixPresentIfRequired(number, metadata)\r\n    return true\r\n  },\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"valid\" and\r\n\t * are grouped in a possible way for this locale. For example, a US number written as\r\n\t * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\r\n\t * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol in the national significant number\r\n\t * are also dropped at this level.\r\n\t *\r\n\t * Warning: This level might result in lower coverage especially for regions outside of\r\n\t * country code \"+1\". If you are not sure about which level to use,\r\n\t * email the discussion group libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tSTRICT_GROUPING(number, candidate, metadata, regExpCache)\r\n\t{\r\n\t\tconst candidateString = candidate.toString()\r\n\r\n\t\tif (!isValidNumber(number, undefined, metadata)\r\n\t\t\t|| !containsOnlyValidXChars(number, candidateString, metadata)\r\n\t\t\t|| containsMoreThanOneSlashInNationalNumber(number, candidateString)\r\n\t\t\t|| !isNationalPrefixPresentIfRequired(number, metadata))\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tnumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n\t\t\tallNumberGroupsRemainGrouped,\r\n\t\t\tregExpCache\r\n\t\t)\r\n  },\r\n\r\n\t/**\r\n\t * Phone numbers accepted are {@linkplain PhoneNumberUtil#isValidNumber(PhoneNumber) valid} and\r\n\t * are grouped in the same way that we would have formatted it, or as a single block. For\r\n\t * example, a US number written as \"650 2530000\" is not accepted at this leniency level, whereas\r\n\t * \"650 253 0000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol are also dropped at this level.\r\n\t * <p>\r\n\t * Warning: This level might result in lower coverage especially for regions outside of country\r\n\t * code \"+1\". If you are not sure about which level to use, email the discussion group\r\n\t * libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tEXACT_GROUPING(number, candidate, metadata, regExpCache)\r\n\t{\r\n\t\tconst candidateString = candidate.toString()\r\n\r\n\t\tif (!isValidNumber(number, undefined, metadata)\r\n\t\t\t|| !containsOnlyValidXChars(number, candidateString, metadata)\r\n\t\t\t|| containsMoreThanOneSlashInNationalNumber(number, candidateString)\r\n\t\t\t|| !isNationalPrefixPresentIfRequired(number, metadata))\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tnumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n\t\t\tallNumberGroupsAreExactlyPresent,\r\n\t\t\tregExpCache\r\n\t\t)\r\n\t}\r\n}\r\n\r\nfunction containsOnlyValidXChars(number, candidate, metadata)\r\n{\r\n  // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\r\n  // national significant number or (2) an extension sign, in which case they always precede the\r\n  // extension number. We assume a carrier code is more than 1 digit, so the first case has to\r\n  // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\r\n  // or 'X'. We ignore the character if it appears as the last character of the string.\r\n  for (let index = 0; index < candidate.length - 1; index++)\r\n  {\r\n    const charAtIndex = candidate.charAt(index)\r\n\r\n    if (charAtIndex === 'x' || charAtIndex === 'X')\r\n    {\r\n      const charAtNextIndex = candidate.charAt(index + 1)\r\n\r\n      if (charAtNextIndex === 'x' || charAtNextIndex === 'X')\r\n      {\r\n        // This is the carrier code case, in which the 'X's always precede the national\r\n        // significant number.\r\n        index++\r\n        if (util.isNumberMatch(number, candidate.substring(index)) != MatchType.NSN_MATCH)\r\n        {\r\n          return false\r\n        }\r\n\t      // This is the extension sign case, in which the 'x' or 'X' should always precede the\r\n\t      // extension number.\r\n      }\r\n      else if (parseDigits(candidate.substring(index)) !== number.ext)\r\n      {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nfunction isNationalPrefixPresentIfRequired(number, _metadata)\r\n{\r\n  // First, check how we deduced the country code. If it was written in international format, then\r\n  // the national prefix is not required.\r\n  if (number.getCountryCodeSource() != 'FROM_DEFAULT_COUNTRY')\r\n  {\r\n    return true\r\n  }\r\n\r\n  const phoneNumberRegion = util.getRegionCodeForCountryCode(number.getCountryCode())\r\n\r\n  const metadata = util.getMetadataForRegion(phoneNumberRegion)\r\n  if (metadata == null)\r\n  {\r\n    return true\r\n  }\r\n\r\n  // Check if a national prefix should be present when formatting this number.\r\n  const nationalNumber = util.getNationalSignificantNumber(number)\r\n  const formatRule = util.chooseFormattingPatternForNumber(metadata.numberFormats(), nationalNumber)\r\n\r\n  // To do this, we check that a national prefix formatting rule was present\r\n  // and that it wasn't just the first-group symbol ($1) with punctuation.\r\n  if (formatRule && formatRule.getNationalPrefixFormattingRule().length > 0)\r\n  {\r\n    if (formatRule.getNationalPrefixOptionalWhenFormatting())\r\n    {\r\n      // The national-prefix is optional in these cases, so we don't need to check if it was\r\n      // present.\r\n      return true\r\n    }\r\n\r\n    if (PhoneNumberUtil.formattingRuleHasFirstGroupOnly(\r\n        formatRule.getNationalPrefixFormattingRule()))\r\n    {\r\n      // National Prefix not needed for this number.\r\n      return true\r\n    }\r\n\r\n    // Normalize the remainder.\r\n    const rawInputCopy = PhoneNumberUtil.normalizeDigitsOnly(number.getRawInput())\r\n\r\n    // Check if we found a national prefix and/or carrier code at the start of the raw input, and\r\n    // return the result.\r\n    return util.maybeStripNationalPrefixAndCarrierCode(rawInputCopy, metadata, null)\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nexport function containsMoreThanOneSlashInNationalNumber(number, candidate)\r\n{\r\n  const firstSlashInBodyIndex = candidate.indexOf('/')\r\n  if (firstSlashInBodyIndex < 0)\r\n  {\r\n    // No slashes, this is okay.\r\n    return false\r\n  }\r\n\r\n  // Now look for a second one.\r\n  const secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1)\r\n  if (secondSlashInBodyIndex < 0)\r\n  {\r\n    // Only one slash, this is okay.\r\n    return false\r\n  }\r\n\r\n  // If the first slash is after the country calling code, this is permitted.\r\n  const candidateHasCountryCode =\r\n      (number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN\r\n       || number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITHOUT_PLUS_SIGN)\r\n\r\n  if (candidateHasCountryCode\r\n      && PhoneNumberUtil.normalizeDigitsOnly(candidate.substring(0, firstSlashInBodyIndex))\r\n          === String(number.getCountryCode()))\r\n  {\r\n    // Any more slashes and this is illegal.\r\n    return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nfunction checkNumberGroupingIsValid(\r\n  number,\r\n  candidate,\r\n  metadata,\r\n  checkGroups,\r\n  regExpCache\r\n) {\r\n  const normalizedCandidate = normalizeDigits(candidate, true /* keep non-digits */)\r\n  let formattedNumberGroups = getNationalNumberGroups(metadata, number, null)\r\n  if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\r\n    return true\r\n  }\r\n\r\n  // If this didn't pass, see if there are any alternate formats that match, and try them instead.\r\n  const alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode())\r\n  const nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n\r\n  if (alternateFormats) {\r\n    for (const alternateFormat of alternateFormats.numberFormats()) {\r\n      if (alternateFormat.leadingDigitsPatterns().length > 0) {\r\n        // There is only one leading digits pattern for alternate formats.\r\n        const leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0])\r\n        if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {\r\n          // Leading digits don't match; try another one.\r\n          continue\r\n        }\r\n      }\r\n      formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat)\r\n      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\r\n        return true\r\n      }\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n/**\r\n * Helper method to get the national-number part of a number, formatted without any national\r\n * prefix, and return it as a set of digit blocks that would be formatted together following\r\n * standard formatting rules.\r\n */\r\nfunction getNationalNumberGroups(\r\n\tmetadata,\r\n\tnumber,\r\n\tformattingPattern\r\n) {\r\n  if (formattingPattern) {\r\n    // We format the NSN only, and split that according to the separator.\r\n    const nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n    return util.formatNsnUsingPattern(nationalSignificantNumber,\r\n                                      formattingPattern, 'RFC3966', metadata).split('-')\r\n\t}\r\n\r\n  // This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.\r\n  const rfc3966Format = formatNumber(number, 'RFC3966', metadata)\r\n\r\n  // We remove the extension part from the formatted string before splitting it into different\r\n  // groups.\r\n  let endIndex = rfc3966Format.indexOf(';')\r\n  if (endIndex < 0) {\r\n    endIndex = rfc3966Format.length\r\n  }\r\n\r\n  // The country-code will have a '-' following it.\r\n  const startIndex = rfc3966Format.indexOf('-') + 1\r\n  return rfc3966Format.slice(startIndex, endIndex).split('-')\r\n}\r\n\r\nfunction allNumberGroupsAreExactlyPresent\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tnormalizedCandidate,\r\n\tformattedNumberGroups\r\n)\r\n{\r\n  const candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN)\r\n\r\n  // Set this to the last group, skipping it if the number has an extension.\r\n  let candidateNumberGroupIndex =\r\n      number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1\r\n\r\n  // First we check if the national significant number is formatted as a block.\r\n  // We use contains and not equals, since the national significant number may be present with\r\n  // a prefix such as a national number prefix, or the country code itself.\r\n  if (candidateGroups.length == 1\r\n      || candidateGroups[candidateNumberGroupIndex].contains(\r\n          util.getNationalSignificantNumber(number)))\r\n  {\r\n    return true\r\n  }\r\n\r\n  // Starting from the end, go through in reverse, excluding the first group, and check the\r\n  // candidate and number groups are the same.\r\n  let formattedNumberGroupIndex = (formattedNumberGroups.length - 1)\r\n  while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0)\r\n  {\r\n    if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex])\r\n    {\r\n      return false\r\n    }\r\n    formattedNumberGroupIndex--\r\n    candidateNumberGroupIndex--\r\n  }\r\n\r\n  // Now check the first group. There may be a national prefix at the start, so we only check\r\n  // that the candidate group ends with the formatted number group.\r\n  return (candidateNumberGroupIndex >= 0\r\n      && endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]))\r\n}\r\n\r\n\r\nfunction allNumberGroupsRemainGrouped\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tnormalizedCandidate,\r\n\tformattedNumberGroups\r\n)\r\n{\r\n  let fromIndex = 0\r\n  if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY)\r\n  {\r\n    // First skip the country code if the normalized candidate contained it.\r\n    const countryCode = String(number.getCountryCode())\r\n    fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length()\r\n  }\r\n\r\n  // Check each group of consecutive digits are not broken into separate groupings in the\r\n  // {@code normalizedCandidate} string.\r\n  for (let i = 0; i < formattedNumberGroups.length; i++)\r\n  {\r\n    // Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\r\n    // doesn't contain the consecutive digits in formattedNumberGroups[i].\r\n    fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex)\r\n    if (fromIndex < 0) {\r\n      return false\r\n    }\r\n    // Moves {@code fromIndex} forward.\r\n    fromIndex += formattedNumberGroups[i].length()\r\n    if (i == 0 && fromIndex < normalizedCandidate.length())\r\n    {\r\n      // We are at the position right after the NDC. We get the region used for formatting\r\n      // information based on the country code in the phone number, rather than the number itself,\r\n      // as we do not need to distinguish between different countries with the same country\r\n      // calling code and this is faster.\r\n      const region = util.getRegionCodeForCountryCode(number.getCountryCode())\r\n      if (util.getNddPrefixForRegion(region, true) != null\r\n          && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\r\n        // This means there is no formatting symbol after the NDC. In this case, we only\r\n        // accept the number if there is no formatting symbol at all in the number, except\r\n        // for extensions. This is only important for countries with national prefixes.\r\n        const nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n        return startsWith\r\n        (\r\n      \t  normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length),\r\n           nationalSignificantNumber\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  // The check here makes sure that we haven't mistakenly already used the extension to\r\n  // match the last group of the subscriber number. Note the extension cannot have\r\n  // formatting in-between digits.\r\n  return normalizedCandidate.slice(fromIndex).contains(number.getExtension())\r\n}"]},"metadata":{},"sourceType":"module"}